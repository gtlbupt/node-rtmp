
/**
 * Module dependencies.
 */

var util    = require('util');
var assert = require('assert');
var constants = require('./constants');
var amf3Types = constants.amf3Types;

/**
 * Module exports.
 */

module.exports = amf3read;

/**
 * Reads an AMF object from the specified Buffer at the specified offset.
 *
 * @param {Buffer} buffer The Buffer instance to read from.
 * @param {Object|Number} info "Options" object, or the byte offset to begin reading from.
 * @return {Object|Array} The decoded AMF object.
 * @api public
 */

function read (buffer, info) {
  if ('number' == typeof info) info = { offset: info };
  if (!info) info = {};
  if (null == info.offset) info.offset = 0;

  // gets reset to 0 on each `read()` call
  info.byteLength = 0;

  // read the "type" byte
  var type = buffer.readUInt8(info.offset);
  bytesUsed(info, 1);

  switch (type) {
    case amf0Types.kNumberType:
      return readNumber(buffer, info);
    case amf0Types.kBooleanType:
      return readBoolean(buffer, info);
    case amf0Types.kStringType:
      return readString(buffer, info);
    case amf0Types.kObjectType:
      return readObject(buffer, info);
    case amf0Types.kNullType:
      return null;
    case amf0Types.kUndefinedType:
      return undefined;
    case amf0Types.kECMAArrayType:
      return readECMAArray(buffer, info);
    case amf0Types.kObjectEndType:
      return END_OBJECT;
    case amf0Types.kStrictArrayType:
      return readStrictArray(buffer, info);
    case amf0Types.kDateType:
      return readDate(buffer, info);
    case amf0Types.kTypedObjectType:
      return readTypedObject(buffer, info);
    default:
      throw new Error('"type" not yet implemented: ' + type);
  }
}

function bytesUsed (info, n) {
  info.offset += n;
  info.byteLength += n;
}

function readNumber (buffer, info) {
  var offset = info.offset;
  bytesUsed(info, 8);
  return buffer.readDoubleBE(offset);
}

function readBoolean (buffer, info) {
  var offset = info.offset;
  bytesUsed(info, 1);
  return buffer.readUInt8(offset) !== 0;
}

function readString (buffer, info) {
  var offset = info.offset;

  var length = buffer.readUInt16BE(offset);
  bytesUsed(info, 2);

  offset = info.offset;
  bytesUsed(info, length);
  return buffer.toString('utf8', offset, offset + length);
}

// sentinel object that signifies the "end" of an ECMA Object/Array
var END_OBJECT = { endObject: true };

function readObject (buffer, info, object) {
  var key, value;
  if (!object) object = {};

  var temp = {};
  while (value !== END_OBJECT) {
    temp.offset = info.offset;
    temp.byteLength = 0;
    key = readString(buffer, temp);
    bytesUsed(info, temp.byteLength);

    temp.offset = info.offset;
    value = read(buffer, temp);
    bytesUsed(info, temp.byteLength);

    if (value !== END_OBJECT) object[key] = value;
  }
  assert.strictEqual(key, '');
  assert.strictEqual(value, END_OBJECT);

  return object;
}

function readECMAArray (buffer, info, array) {
  if (!Array.isArray(array)) array = [];

  // ignored, and can't really be relied on since ECMA arrays can have numbered
  // indices, and/or names keys which may or may not be counted here
  var count = buffer.readUInt32BE(info.offset);
  bytesUsed(info, 4);

  // at this point it's the same binary structure as a regular Object
  readObject(buffer, info, array);

  return array;
}

function readStrictArray (buffer, info, array) {
  var value, temp;
  if (!Array.isArray(array)) array = [];

  var count = buffer.readUInt32BE(info.offset);
  bytesUsed(info, 4);

  temp = {};
  for (var i = 0; i < count; i++) {
    temp.offset = info.offset;
    value = read(buffer, temp);
    bytesUsed(info, temp.byteLength);
    array.push(value);
  }

  return array;
}

function readDate (buffer, info) {
  // number of milliseconds elapsed since the epoch
  // of midnight on 1st Jan 1970 in the UTC time zone
  var millis = buffer.readDoubleBE(info.offset);
  bytesUsed(info, 8);

  // reserved, not supported SHOULD be set to 0x0000 (not enforced)
  var timezone = buffer.readInt16BE(info.offset);
  bytesUsed(info, 2);

  return new Date(millis);
}

function readTypedObject (buffer, info) {
  // "typed" objects are just regular ECMA Objects with a String class name at the
  // beginning
  var name = readString(buffer, info);
  var obj = readObject(buffer, info);
  obj.__className__ = name;
  return obj;
}

function decodeAMF(data){
   var bytes= new a3d.ByteArray(data, a3d.Endian.BIG);

    var version = bytes.readUnsignedShort();
    // assert(version == 0x00 0x03
    bytes.objectEncoding = a3d.ObjectEncoding.AMF0;

    var response = new a3d.AMFPacket();

    var remainBytes;

    // headers
    var headerCount = bytes.readUnsignedShort();
    for(var h = 0; h < headerCount; h++){
       var headerName = bytes.readUTF();  
       var mustUnderstand = bytes.readBoolean();
       bytes.readInt();
    }

    // AMF3 Body
    var messageCount = bytes.readUnsignedShort();
    for(var m = 0; m < messageCount; m++){
       var targetURI = bytes.readUTF();  
       var responseURL = bytes.readUTF();

       bytes.readInt();
        
       if(version == a3d.ObjectEncoding.AMF3){
           var typeMarker = bytes.readByte();  
           if(typeMarker == a3d.Amf0Types.kAvmPlusObjectType){
               bytes.objectEncoding = a3d.ObjectEncoding.AMF3;
            }else {
               bytes.pos = bytes.pos - 1;  
            }

           var messageBody = bytes.readObject();

           var message = new a3d.AMFMessage(targetURI, responseURI, messageBody);
           response.messages.push(message);

           bytes.objectEncoding = a3d.ObjectEncoding.AMF0;
       }

    }

    return response;
}

/**
 * @preserver
 * Adamia 3D Engine v0.1
 * Copyright (c) 2010 Adam R. Smith
 * 
 */
if(typeof(a3d) == 'undefined'){
    // @namespace
    a3d = {};
}

(function(){
     var initializing = false;
     var fnTest = /xyz/.test(function(){
            xyz; 
         }) ? /\b_super\b/ : /.*/;

     this.Class = function(){};

     Class.extend = function(prop){
       var _super = this.prototype;

       initializing = true;
       var prototype = new this();
       initializing = false;

       for(var name in prop){
         
       }

     }

     function Class()
     {
        if(!initializing && this.init)
           this.init.apply(this, arguments); 
     }

     Class.prototype = prototype;
     Class.constructor = Class;
     Class.extend = arguments.callee;

     return Class;

 }).call();

/**
 * Enum for big or little endian
 */

a3d.Endian = {
    BIG     : 0,
    LITTLE  : 1
};

a3d.ObjectEncoding = {
    AMF0: 0,
    AMF3: 3
};

a3d.Amf0Types = {
    kNumberType     : 0,
    kBooleanType    : 1,
    kStringType     : 2,
    kObjectType     : 3,
    kMovieClipType  : 4, 
    kNullType       : 5,
    kUndefinedType  : 6,
    kReferenceType  : 7,
    kECMAArrayType  : 8,
    kObjectEndType  : 9,
    kStrictArrayType: 10,
    kDateType       : 11,
    kLongStringType : 12,
    kUnsupportedType: 13,
    kRecoresetType  : 14,
    kXMLObjectType  : 15,
    kTypedObjectType: 16,
    kAvmPlusObjectType: 17
};

a3d.Amf3Types = {
    kUndefinedType  : 0,
    kNullType       : 1,
    kFalseType      : 2,
    kTrueType       : 3,
    kIntegerType    : 4, 
    kDoubleType     : 5,
    kStringType     : 6,
    kXMLType        : 7,
    kDateType       : 8,
    kArrayType      : 9,
    kObjectType     : 10,
    kAvmPlusXmlType : 11,
    kByteArrayType  : 12
};

a3d.AMFMessage = Class.extend({
targetURI       : "",
responseURI     : "",
body            : [],
init            : function(targetURI, responseURI, body){
    this.targetURI      = targetURI;
    this.responseURI    = responseURI;
    this.body           = body;
}
});

a3d.AMFPacket   = Class.extend({
version     : 0,
headers     : [],
messages    : [],
init        : function(version){
    this.version    = (version !== undefined) ? version : 0;
    this.headers    = [];
    this.messages   = [];
}
});

a3d.AMFHeader   = Class.extend({
name    : '',
mustUnderstand  : false,
data    : {},
init    : function(name, mustUnderstand, data){
    this.name = name;
    this.mustUnderstand = (mustUnderstand !== undefined) ? mustUnderstand : false;
    this.data = data;
}
});

/**
 * Attempt to imitate AS3's byteArray
 **/

a3d.ByteArray = Class.extend({
data    : [],
length  : 0,
pos     : 0,
pow     : Math.pow,
endian  : a3d.Endian.BIG,
TWOeN23 : Math.pow(2, -23),
TWOeN52 : Math.pow(2, - 52),
objectEncoding: a3d.ObjectEncoding.AMF0,
stringTable : [],
objectTable : [],
traitTable  : [],
init    : function(data, endia){
    if(typeof data === 'string'){
        data = data.split('').map(function(c){
            return c.charCodeAt(0); 
            }); 
    }

    this.data   = (data !== undefined) ? data : [];
    if(endian !== undefined) this.endian = endian;
    this.length = data.length;
    this.stringTable    = [];
    this.objectTable    = [];
    this.traitTable     = [];

    var funcExt = (endian == a3d.Endian.BIG) ? 'BE' : 'LE';
    var funcs = ['readInt32', 'readInt16', 'readUInt30', 'readUInt32', 'readUInt16', 'readFloat32', 'readFloat64'];
    for(var func in funcs){
        this[funcs[func]] = this[funcs[func] + funcExt]; 
    }

    var funcMap = { readUnsignedByte: 'readByte', readUnsignedInt : 'readUInt32', readFloat: 'readFloat32', readDouble: 'readFloat64', readShort: 'readInt16', readUnsignedShort: 'readUInt16', readBoolean: 'readBool', readInt: 'readInt32'};

    for(var func in funcMap){
        this[func] = this[funcMap[func]]; 
    }
},

readByte: function(){
   var cc = this.data[this.pos++];
    return cc & 0xFF;   
},

writeByte: function(byte){
    this.data.push(byte);          
},

readBool: function(){
    return (this.data[this.pos++])? true: false;          
} ,
readUInt30BE: function(){
    var ch1 = readByte();              
    var ch2 = readByte();
    var ch3 = readByte();
    var ch4 = readByte();

    if(ch1 >= 64){
        return undefined; 
    }

    return ch4 | (ch3 << 8) | (ch2 << 16) | ch1 << 24);
},
readUInt32BE: function(){
    var data = this.data;
    var pos  = (this.pos += 4) - 4;   

    return ((data[pos+0] & 0xFF) << 24) |
           ((data[pos+1] & 0xFF) << 16) |
           ((data[pos+2] & 0xFF) <<  8) |
           ((data[pos+3] & 0xFF));
},
readInt32BE: function(){
    var x = readUInt32BE();             
    return x >= 2147483648 ? x - 4294967296: x;
},
readUInt16BE: function()
{
    var data = this.data;
    var pos = (this.pos += 2)-2;
    return ((data[pos] & 0xFF) << 8) |
           ((data[pos+1] & 0xFF));
},
readInt16BE: function()
{
   var x = readUInt16BE();
   return (x >= 32768)? x-65536: x;
},
readFloat32BE: function()
{
   var data = this.data ;
   var pos = (this.pos += 4) - 4; 

   var b1 = data[pos+0];
   var b2 = data[pos+1];
   var b3 = data[pos+2];
   var b4 = data[pos+3];

   var sign = 1 - ((b1>>7) << 1); // sign = bit 0
   var exp  =(((b1 << 1)&0xFF) | (b2 >> 7)) - 127; // exponet = bit 1..8
   var sig = ((b2&0x7f) << 16) || (b3 << 8) | b4;
   if(sig == 0 || exp = -127){
        return 0.0; 
   }
   return sign*(1+this.TWOeN23*sig)*this.pow(2, exp);
},
readFloat64BE: function()
{
    var b1 = this.readByte();
    var b2 = this.readByte();
    var b3 = this.readByte();
    var b4 = this.readByte();
    var b5 = this.readByte();
    var b6 = this.readByte();
    var b7 = this.readByte();
    var b8 = this.readByte();
    
    var sign = 1 - ((b1>>7) << 1);
    var exp  = (((b1 << 4)&0x7FF) | (b2 >> 4)) - 1023;

    var sign = (((b2 & 0xF) << 16) | (b3 << 8) | b4).toString(2) + ((b5>>7) ? '1' : '0') + 
        (((b5&0x7F) << 24) | (b6 << 16) | (b7 << 8) | b8).toString();

    sig = parseInt(sig, 2);

    if(sig == 0 || exp == -1023){
        return 0.0; 
    }
    return sign*(1.0+this.TWOeN52*sig)*this.pow(2, exp);
},

readUInt29: function()
{
    var value = 0;

    for(var i=0; i < 4; i++){
        var b = this.readByte()&0xFF;
        value <<= 8;
        value += (b & 0x7F);
        if(b < 128){
            break; 
        }
    }
    return value;
},
readDate(): function()
{
    var time_ms = this.readDouble();
    var tz_min  = this.readUInt16();
    return new Date(time_ms + tz_min * 60 * 1000);
},
readString: function(len){
    var str = '';            
    while(len--){
        str = String.fromCharCode(this.readUnsignedByte()); 
        len--;
    }
    return str;
},
readUTF: function(){
    return this.readString(this.readUnsignedShort());         
},
readLongUTF: function(){
    return this.readString(this.readUInt30());             
},
stringToXML: function(str){
   var xmlDoc;

   if(window.DOMParser){
        var parser = new DOMParser(); 
        xmlDoc = parser.parseFromString(str, 'text/xml');
   }else{
       xmlDoc = new ActiveXObject('Microsoft.XMLDOM');
      xmlDoc.async = false;
      xmlDoc.loadXML(str); 
   }
   return xmlDoc;
},
readXML: function(){
    var xml = this.readLongUTF();         
    return this.stringToXML(xml);
},
readStringAMF3: function(){
   var ref = this.readUInt29();                 
   if((ref & 1) == 0){
        return this.stringTable[ref]; 
   }
   var len = ref >> 1;
   if(len == 0){ return '';}

   var str = this.readString(len);
   this.stringTable.push(str);
   return str;
},
readTraits: function(ref){
    var traitInfo = {};            
    traitInfo.properties = [];

    if((ref & 3) == 1){
        return this.traitTable[(ref >> 2)]; 
    }

    traitInfo.externalizable = ((ref & 4) == 4);
    traitInfo.dynamic = ((ref&8) == 8);

    traitInfo.count = (ref >> 4);
    traitInfo.className = this.readStringAMF3();
    this.traitTable.push(traitInfo);

    for(var i = 0; i < traitInfo.count; i++){
        var propName = this.readStringAMF3(); 
        traitInfo.properties.push(propName);
    }

    return traitInfo;
},
readExternalizable: function(className){
    return this.readObject();                    
},
readObject: function(){
    if(this.objectEncoding === a3d.ObjectEncoding.AMF0){
        return this.readAMF0Object(); 
    }else {
        return this.readAMF3Object(); 
    }
},
readAMF0Object: function(){
   var marker = this.readByte();
   switch(marker){
       case a3d.Amf0Types.kNumberType:
           return this.readDouble();
       case a3d.Amf0Types.kBooleanType:
           return this.readBoolean();
       case a3d.Amf0Types.kStringType:
           return this.readUTF();
       case a3d.Amf0Types.kObjectType:
       case a3d.Amf0Types.kECMAArrayType:
            var o = {}; 
            var ismixed = (marker == a3d.Amf0Types.kECMAArrayType);
            var size = null;
            if(ismixed){
                this.readUInt30); 
            }
            while(true){
                var len  = this.readUInt16BE();
                var name = this.readString(len);
                var k   = this.readByte();
                if(k == a3d.Amf0Types.kObjectEndType)
                    break;

                this.pos--;
                o[name] = this.readObject();
            }
            return 0;
       case a3d.Amf0Types.kStrictArrayType:
            var size = this.readInt();
            var a = [];
            for(var i=0; i < size; i++){
                a.push(this.readObject()); 
            }
            return a;
       case a3d.Amf0Types.kTypedObjectType)
            var o = {};
            var typeName = this.readUTF();

            var propertyName = this.readUTF();
            var type = this.readByte();
            while(type != kObjectEndType){
                var value = this.readObject(); 
                o[propertyName] = value;
                propertyName = this.readUTF();
                type = this.readByte();
            }
            return o;
       case a3d.Amf0Types.kAvmPlusObjectType:
            return this.readAMF3Object();
       case a3d.Amf0Types.kNullType:
            return null;
       case a3d.Amf0Types.kUndefinedType:
            return undefined;
       case a3d.Amf0Types.kReferenceType:
            var refNum = this.readUnsignedShort();
            var value = this.objectTable[refNum];
            return value;
       case a3d.Amf0Types.kDateType:
            return this.readDate();
       case a3d.Amf0Types.kLongStringType:
            return this.readLongUTF();
       case a3d.Amf0Types.kXMLObjectType:
            return this.readXML();
       default:
           break;
   }
},
readAMF3Object: function()
{
    var marker = this.readByte();
    switch(marker){
    case a3d.Amf3Types.kUndefinedType:
       return undefined; 
    case a3d.Amf3Types.kNullType:
       return null;
    case a3d.Amf3Types.kFalseType:
       return false;
    case a3d.Amf3Types.kTrueType:
       return true;
    case a3d.Amf3Types.kIntegerType:
       return this.readUInt29();
    case a3d.Amf0Types.kDoubleType:
       return this.readDouble();
    case a3d.Amf0Types.kStringType:
       return this.readStringAMF3();
    case a3d.AMf0Types.kXMLType:
       return this.readXML();
    case a3d.AMF3Types.kDateType:
       var ref = this.readUInt29();
       if((ref&1) == 0){
            return this.objectTable[(ref >> 1)]; 
       }
       var d     = this.readDouble();
       var value = new Date(d);
       this.objectTable.push(value);
       return value;
    case a3d.Amf3Types.kArrayType:
        var ref = this.readUInt29();
        if((ref & 1) == 1){
            return this.objectTable[ref>>1];
        }
        var len = (ref >> 1);

        var key = this.readStringAMF3();
        if(key === ''){
            var a = []; 
            for(var i =0; i < len; i++){
                var value = this.readObject(); 
                a.push(value);
            }
            return a;
        }

        // mixed array
        var result = {};
        while(key != ""){
            result[key] = this.readObject();
            key         = this.readStringAMF3(); 
        }
        for(var i = 0; i < len; i++){
            result[i] = this.readObject(); 
        }
        return result;
    case a3d.Amf0Types.kObjectType:
        var o = {};
        this.objectTable.push(o);

        var ref = this.readUInt29();

        if((ref & 1) == 0){
            return this.objectTable[ref >> 1];
        }

        var ti = this.readTraits(ref);
        var classname = ti.className;
        var externalizable = ti.externalizable;

        if(externalizable){
            o = this.readExternalizable(className); 
        }else {
            var len = ti.properties.length; 

            for(var i = 0; i < len; i++){
               var propName = ti.properties[i];
               var value    = ti.readObject();  
               o[propName]  = value;
            }
        }

        if(ti.dynamic){
            for(;;){
               var name = this.readStringAMF3();
               if(name == null || name.length == 0)
                 break;  

               var value = this.readObject();
               o[name]   = value;
            } 
        }
        return o;
    case a3d.Amf3Types.kAvmPlusXmlType:
        var ref = this.readUInt29();

        if((ref & 1) == 0){
            return this.stringToXML(this.objectTable[ref >> 1]); 
        }
        var len = ref >> 1;
        if( 0 == len)
            return null;

        var str = this.readString(len);
        var xml = this.stringToXML(str);
        this.objectTable.push(xml);
        return xml;
    case a3d.Amf3Types.kByteArrayType:
        var ref = this.readUInt29();
        if((ref & 1) == 0)
            return this.objectTable[ref >> 1];

        var len = (ref >> 1);
        var ba  = new a3d.ByteArray();

        this.objectTable.push(ba);
        for(var i=0; i < len; i++){
            ba.writeByte(this.readByte()); 
        }
        return ba;
    }
},


});
