
/**
 * Module dependencies.
 **/

var util    = require('util');
var assert  = require('assert');
var constants = require('./constants');
var amf0Types = constants.amf0Types;

/**
 * Module exports.
 **/

module.exports  = write

/**
 * References:
 *   - http://osflash.org/documentation/amf
 *   - http://en.wikipedia.org/wiki/Action_Message_Format
 *   - http://download.macromedia.com/pub/labs/amf/amf0_spec_121207.pdf
 *   - http://download.macromedia.com/pub/labs/amf/amf3_spec_121207.pdf
 */

/*
amf0Types = {
  kNumberType:         0,
  kBooleanType:        1,
  kStringType:         2,
  kObjectType:         3,
  kMovieClipType:      4,
  kNullType:           5,
  kUndefinedType:      6,
  kReferenceType:      7,
  kECMAArrayType:      8,
  kObjectEndType:      9,
  kStrictArrayType:   10,
  kDateType:          11,
  kLongStringType:    12,
  kUnsupportedType:   13,
  kRecordsetType:     14,
  kXMLObjectType:     15,
  kTypedObjectType:   16,
  kAvmPlusObjectType: 17
};

amf3Types = {
  kUndefinedType:   0,
  kNullType:        1,
  kFalseType:       2,
  kTrueType:        3,
  kIntegerType:     4,
  kDoubleType:      5,
  kStringType:      6,
  kXMLType:         7,
  kDateType:        8,
  kArrayType:       9,
  kObjectType:     10,
  kAvmPlusXmlType: 11,
  kByteArrayType:  12
};
*/


/*
function write(objArr){
    if(!util.isArray(objArr)){
        throw new Error("need to be array");
    }
    var chunks = [];
    objArr.forEach(function(val, idx, arr){
          chunks.push(val);
    });
    return Buffer.concat(chunks);
}
*/

function write(obj){
    assert(typeof obj === 'object');
    assert('type' in obj);
    assert('value' in obj);

    var type    = obj['type'];
    var value   = obj['value'];
    var key_buf = null;

    if('key' in obj){
        var key = obj['key'];
        key_buf = new Buffer(2 + Buffer.byteLength(key,'utf8'));
        key_buf.writeUInt16BE(Buffer.byteLength(key,'utf8'),0);
        new Buffer(key).copy(key_buf, 2);
    }


    switch (type) {
        case amf0Types.kNumberType:
            var buf = new Buffer(1+8);
            buf.writeUInt8(type,0);
            buf.writeDoubleBE(value,1);
            break;
        case amf0Types.kBooleanType:
            var buf = new Buffer(1+1);
            buf.writeUInt8(type,0);
            buf.writeUInt8(value?1:0, 1);
            break;
        case amf0Types.kStringType:
            var buf = new Buffer(1+2 + Buffer.byteLength(value,'utf8'));
            buf.writeUInt8(type,0);
            buf.writeUInt16BE(Buffer.byteLength(value,'utf8'),1);
            new Buffer(value).copy(buf, 3);
            break;
        case amf0Types.kObjectType:
            var chunks = [];
            chunks.push(new Buffer([0x03]));
            assert(util.isArray(value));
            for(var i =0; i < value.length; i++){
                chunks.push(write(value[i])); 
            }
            chunks.push(new Buffer([0x00,0x00,0x09]));
            buf = Buffer.concat(chunks);
            break;
        case amf0Types.kNullType:
            buf = new Buffer([0x05]);
            break;
        case amf0Types.kUndefinedType:
            buf = new Buffer([0x06]);
            break;
        case amf0Types.kECMAArrayType:
            var chunks = [];
            var header = new Buffer(5);
            header.writeUInt8(0x08,0);
            header.writeUInt32BE(value.length,1);
            chunks.push(header);
            assert(util.isArray(value));
            for(var i =0; i < value.length; i++){
                chunks.push(write(value[i])); 
            } 
            chunks.push(new Buffer([0x00,0x00,0x09]));
            buf = Buffer.concat(chunks);
            break;
        case amf0Types.kStrictArrayType:
            var chunks = [];
            var header = new Buffer(5);
            header.writeUInt8(0x0a, 0);
            header.writeUInt32BE(value.length,1);
            chunks.push(header);
            assert(util.isArray(value));
            for(var i =0; i < value.length; i++){
                chunks.push(write(value[i])); 
            } 
            buf = Buffer.concat(chunks);
            break;
        case amf0Types.kObjectEndType:
        case amf0Types.kDateType:
        case amf0Types.kTypedObjectType:
        default:
            throw new Error('"type" not yet implemented: ' + type);
    }

    if('key' in obj){
        return Buffer.concat([key_buf, buf]);
    }else {
        return buf; 
    }
}

/*
console.log('Number ', write({type: amf0Types.kNumberType,  value: 1}));
console.log('Boolean',write({type: amf0Types.kBooleanType, value: 1}));
console.log('Boolean',write({type: amf0Types.kBooleanType, value: 0}));
console.log('String ',write({type: amf0Types.kStringType,  value: "gao"}));
console.log('Object ', write({type: amf0Types.kObjectType,  value: 
         [
//            {type: amf0Types.kStringType, key:"level", value:"status"},
//            {type: amf0Types.kStringType, key:"code",  value:"NetConnection.Connect.Success"},
//            {type: amf0Types.kStringType, key:"description",  value:"connection succeeded"},
//            {type: amf0Types.kNumberType, key:"objectEncoding",  value:0},
//            {type: amf0Types.kNumberType, key:"time",  value:1399428497},
              {type: amf0Types.kECMAArrayType, key:"data",  value:
                [
                 {type: amf0Types.kStringType, key:"version", value: "0.14.306"} 
                ]
             },
            {type: amf0Types.kStringType, key:"clientid",  value:'1399428496Qdj6LRGa'}
        ]
        }));
console.log('null   ',write({type: amf0Types.kNullType,  value: null}));
console.log('undefined',write({type: amf0Types.kUndefinedType,  value: undefined}));
*/
